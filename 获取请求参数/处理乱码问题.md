---
up:
  - "[[Spring MVC 課程描述]]"
---
> **注意**：在 Servlet 阶段，是通过`request.setCharacterEncoding("UTF-8");`的方式解决乱码问题的。虽然 SpringMVC 中可以使用`HttpServletRequest`对象，但是没有效果。原因也很简单，是因为请求参数获取在前，设置编码格式在后

事实胜于雄辩，简单测试下

后台测试代码

```java
@RequestMapping("/testServletAPI3")
public String testServletAPI3(HttpServletRequest request) throws UnsupportedEncodingException {
    request.setCharacterEncoding("UTF-8");
    String username = request.getParameter("username");
    System.out.println("username=" + username);
    return "success";
}
```

前台测试代码

```html
<form th:action="@{/paramController/testServletAPI3}" method="post">
    用户名：<input type="text" name="username"><br/>
    <input type="submit" value="测试请求参数">
</form>
```

后台日志信息

```shell
username=å¼ ä¸�
```

可能你会说，上面的测试都是`post`请求，如果是`get`请求呢？~~问得好，下次不要问了~~

```html
<a th:href="@{/paramController/testServletAPI3(username='张三')}">通过setCharacterEncoding设置编码</a><br/>
```

后台日志信息

```shell
username=张三
```

**Q**：这是为什么呢？怎么`get`请求还搞特殊？

**A**：这是因为 Tomcat 的 conf 目录下的 `server.xml`中配置了`URIEncoding="UTF-8"`的原因。这样`get`请求的乱码问题就可以一次性解决了

```xml
<Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" URIEncoding="UTF-8"/>
```

如果一开始就没有配置，那`get`请求也会乱码，所以拜托不是`get`请求搞特殊了喂！
 
**Q**：既然在`server.xml`配置下编码格式就行了，为什么只支持`get`请求啊？还说不是搞特殊？

**A**：...你赢了

**Q**：退一步来说，`post`请求能不能在请求参数获取之后再去处理也可以吧，只要知道其本身的编码

**A**：试一下咯

我们先通过 [在线乱码恢复](http://www.mytju.com/classcode/tools/messycoderecover.asp) 看下，乱码的文本实际编码是什么

![[1755429045113_4hheBBCXqF.png]]

很显然，乱码本身为`ISO-8859-1`格式，我们转换为`UTF-8`编码格式即可

后台测试代码

```java
// 对其进行iso-8859-1解码并重新UTF-8编码
username = new String(username.getBytes("ISO-8859-1"), "UTF-8");
System.out.println("username=" + username);
```

后台日志信息

```shell
username=张三
```

有上述测试可知，要想处理乱码问题，思路有二：

1. 获取请求参数之后，手动解码编码。但是这种方式要求每次处理`post`请求的请求参数都要手动处理，太不人性化了吧。~~你嫌烦，我还嫌烦呢~~（❌）

2. 获取请求参数之前“做手脚”：发送请求之前，也就是在`Servlet`处理请求之前（👌）

那什么组件时在`Servlet`之前执行的呢？
 
众所周知 ~~（我不知道）~~，JavaWeb 服务器中三大组件：监听器、过滤器、`Servlet`。很显然，监听器和过滤器都在`Servlet`之前
 
 - `ServletContextListener`监听器：只是来监听`ServletContext`的创建和销毁，都是只执行一次

 - `Filter`过滤器：只要设置了过滤路径，只要当前所访问的请求地址满足过滤路径，那么都会被过滤器过滤 

很显然，用过滤器就可以做到在发送请求之前“做手脚”，这样所有请求都要经过过滤器的处理，再交给`DispatherServlet`处理
 
但是，这个过滤不需要我们写，SpringMVC 已为我们准备好了，只要再`web.xml`中进行配置即可

我们先对`web.xml`进行配置

```xml
<!--处理编码-->
<filter>
    <filter-name>characterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
        <param-name>forceResponseEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

重启后测试，看下后台日志信息

```shell
username=张三
```

Perfect! 配置很简单，测试结果立竿见影，乱码问题得到了解决

> “知其然，知其所以然”

这个神奇的`CharacterEncodingFilter`到底干了什么？我们一起来看下源码一探究竟

![[1755429045113_aXTW2zT0xd.png]]

我们知道，在`<init-param>`标签中配置的属性值，其实就是为对应类进行的属性注入。这里可以很清楚地看到`encoding`和`forceResponseEncoding`两个属性值，同时注意到`encoding`被`@Nullable`注解修饰，表示其可以为空，`forceResponseEncoding`默认为`false`，即不配置不生效

另外，看一个`Filter`最重要的找它的`doFilter()`方法

![[1755429743133_HVS6GobGS4.png]]

可以看到，`CharacterEncodingFilter`类中并没有`doFilter()`方法，那去它的基类中找找吧~

![[1755429743140_p4hFei2JLC.png]]

直接读源码

```java
@Override
public final void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)
    throws ServletException, IOException {
    // 就是判断是不是http请求和相应，不管
    if (!(request instanceof HttpServletRequest) || !(response instanceof HttpServletResponse)) {
        throw new ServletException("OncePerRequestFilter just supports HTTP requests");
    }
    // 拿到一些了对象和参数，继续往下看看有什么用处
    HttpServletRequest httpRequest = (HttpServletRequest) request;
    HttpServletResponse httpResponse = (HttpServletResponse) response;
    String alreadyFilteredAttributeName = getAlreadyFilteredAttributeName();
    boolean hasAlreadyFilteredAttribute = request.getAttribute(alreadyFilteredAttributeName) != null;
    // 三个条件判断，一一看下
    // 1、跳过转发或不过滤的，就直接进行过滤链的下一个请求（确信）
    if (skipDispatch(httpRequest) || shouldNotFilter(httpRequest)) {
        filterChain.doFilter(request, response);
    }
    // 2、已经过滤属性的，多了一层判断，貌似时处理错误转发的？（不太懂）
    else if (hasAlreadyFilteredAttribute) {
        if (DispatcherType.ERROR.equals(request.getDispatcherType())) {
            doFilterNestedErrorDispatch(httpRequest, httpResponse, filterChain);
            return;
        }
        filterChain.doFilter(request, response);
    }
    // 3、其他情况（应该就是正常情况吧）：设置下属性，再走 doFilterInternal 方法（还有印象吗？这个方法我们在其子类CharacterEncodingFilter中看到过的，那就顺藤摸瓜）
    else {
        request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE);
        try {
            doFilterInternal(httpRequest, httpResponse, filterChain);
        }
        finally {
            request.removeAttribute(alreadyFilteredAttributeName);
        }
    }
}
```

回到`CharacterEncodingFilter`中看下`doFilterInternal()`方法

```java
@Override
protected void doFilterInternal(
    HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
    throws ServletException, IOException {
	// 获取编码格式，很明显就是获取web.xml中的配置值了（确信）
    String encoding = getEncoding();
    if (encoding != null) {
        // 二选一：配置了forceRequestEncoding为true或者请求的字符编码没有被设置，就给请求对象设置编码格式
        if (isForceRequestEncoding() || request.getCharacterEncoding() == null) {
            request.setCharacterEncoding(encoding);
        }
        // 配置了forceResponseEncoding为true，就给响应对象设置编码格式
        if (isForceResponseEncoding()) {
            response.setCharacterEncoding(encoding);
        }
    }
    filterChain.doFilter(request, response);
}
```

可以看出

- 没有在`web.xml`设置编码格式就不管了，爱咋咋地
- 设置了`encoding`就看下是请求对象还是响应对象
    - 请求对象：如果打开了`forceRequestEncoding`即 _强制请求编码_ 开关，就给设置下编码；就算没打开这个开关，只要请求对象还没有设置过字符编码格式，那就给它设置下
    - 响应对象：只有打开了`forceResponseEncoding`即 _强制响应编码_ 开关，才给设置编码