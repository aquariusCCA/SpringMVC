---
up:
  - "[[Spring MVC 課程描述]]"
  - "[[HttpMessageConverter]]"
  - "[[ResponseEntity]]"
---
文件上传要求`form`表单的请求方式必须为`post`，并且添加属性`enctype="multipart/form-data"`

SpringMVC 将上传的文件封装到`MultipartFile`对象中，通过此对象可以获取文件相关信息

# 1）添加依赖

`commons-fileupload`的 jar 包是上传功能必不可少的

```xml
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.4</version>
</dependency>
```

---

# 2）配置文件上传解析器

SpringMVC 配置文件中添加`CommonsMultipartResolver`的依赖注入

```xml
<!--配置文件上传解析器，将上传文件自动封装为MutilpartFile对象-->
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"></bean>
```

---

# 3）后台代码

使用`MultipartFile`对象接收上传文件

```java
@PostMapping("/testUpload")
public String testUpload(MultipartFile photo, HttpSession session) throws IOException {
    // 目标目录
    String photoPath = session.getServletContext().getRealPath("photo");
    File file = new File(photoPath);
    if (!file.exists()) {
        file.mkdir();
    }
    // 目标文件名
    String fileName = photo.getOriginalFilename();
    // 上传文件到服务器
    photo.transferTo(new File(photoPath + File.separator + fileName));
    return "success";
}
```

---

# 4）前台代码

要求请求方式必须为 `post`，并且 `enctype` 属性值必须为 `multipart/form-data`

**Q**：enctype 是什么？

**A**：enctype 即 `encode type`，表示编码类型，它规定了在发送到服务器之前应该如何对表单数据进行编码

 默认地，form 表单数据编码默认值为`application/x-www-form-urlencoded`。除此之外，`enctype`还可以设置为`text/plain`

这三种类型总结一下就是：

- `application/x-www-form-urlencoded`：默认值，URL 编码

- `multipart/form-data`：文件类型

- `text/plain`：纯文本格式类型

```html
<form th:action="@{/fileUploadDownloadController/testUpload}" method="post" enctype="multipart/form-data">
    头像：<input type="file" name="photo"/><br/>
    <input type="submit" value="上传"/>
</form>
```

测试结果

![[1755508001254_HaJcvlPCN1.gif]]

查看文件是否上传成功

![[1755525747593_rKZLrrmcMj.png]]

---

# 5）处理同名问题

如果多次上传同名文件，会发现原文件会被同名新文件替换（覆盖）掉，如何解决这个问题呢？

其实，处理同名问题有多种方式，这里采用`UUID`生成随机序列来实现，只需要做简单的修改即可

```java
@PostMapping("/testUpload")
public String testUpload(MultipartFile photo, HttpSession session) throws IOException {
    // 目标目录
    String photoPath = session.getServletContext().getRealPath("photo");
    File file = new File(photoPath);
    if (!file.exists()) {
        file.mkdir();
    }
    // 目标文件名
    String srcName = photo.getOriginalFilename();
    String suffixName = srcName.substring(srcName.lastIndexOf("."));
    String prefixName = UUID.randomUUID().toString();
    String destName = prefixName + suffixName;
    // 上传文件到服务器
    photo.transferTo(new File(photoPath + File.separator + destName));
    return "success";
}
```

再次测试

![[1755525747600_Y2LH77FsvG.png]]

可以看到，最新上传的文件名为一串随机序列，这样就避免同名文件上传出现覆盖的问题了